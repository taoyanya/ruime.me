---
title: "前端面试知识汇总"
date: 2023-04-12
---

### Babel

主要用于将 ECMAScript2015+转换为先后兼容的 javascript 代码

包括：语法转换，polyfill 实现目标环境中缺少的内容

### this 的绑定

1、默认绑定，独立函数执行，非严格模式下，this 指向 window，严格模式下，this 为 undefined

2、隐式绑定，函数作为对象的方法执行，this 指向该对象

3、显示绑定，使用 apply/call/bind 方法调用函数，this 指向所指定的 thisArg

4、new 绑定，函数作为结构函数，用 new 执行，this 指向所创建的实例对象

优先级：显示绑定/new 绑定>隐式绑定>默认绑定

new 不能和 apply/call 一起使用，new 高于 bind，bind 优先级高于 apply/call

**总结：new>bind>apply/call>隐式绑定>默认绑定**

**如果显示绑定传入一个 null 或者 undefined，使用默认绑定规则绑定 window，因为 null 和 undefined 没有包装类**

### 箭头函数

1、没有 this 绑定，this 从上级作用域获取

2、不能使用 new 关键字，不能当作构造函数

3、没有 arguments 属性

4、箭头函数没有原型

### computed 和 watch 的区别

1、传入的参数不同

computed 一般传入一个函数，或者传入一个对象，但是对象必须有 get 和 set 方法

watch 一般接受两个参数，第一个为监听的变量，第二个为监听的变量发生变化时所要执行的回调函数，可以传入第三个参数，为一个对象，可以设置是否立即监听，是否深度监听

2、使用场景不同

computed 主要用于对响应式的计算处理，同时具有缓存，只有当所监听的变量发生变化时，才会重新进行计算，不支持异步操作

watch 主要用于对响应式数据的监听，当数据发生变化时，执行监听函数，同时支持异步

### Vue 中$nextTick 的作用和原理

vue 中更新 DOM 是异步执行的，当数据发生变化时，Vue 会开启一个更新队列，视图要等到队列中的数据更新完成后才会更新，所以$nextTick 可以解决这样的问题，可以对更新后的 DOM 进行操作。

原理：把参数中的回调函数放入 callback 队列中，把执行函数放到微任务或者宏任务中，执行函数依次执行 callback 中的回调

### new 会发生什么

1、创建一个新的实例对象

2、把实例对象的原型 proto 指向构造函数的原型 prototype

3、把 this 指向新的实例对象

4、执行构造函数中的代码

5、返回这个实例对象

### 浏览器输入 url 发生什么

1、解析 url，浏览器会利用 DNS 查询域名的 IP，如果没有在浏览器的缓存中找到对应 IP 地址，就会去到本机的 host 文件进行查询，如果还是没有找到 IP 地址，就会发生 DNS 查询。

2、查询到目标域名的 IP 后，就向发起 TCP 连接，经过三次握手建立连接，判断是否是 HTTP 缓存，如果是强缓存且在有效期中，就不再向服务器发起请求，如果是协商缓存，向服务器发起请求，如果是有效期就返回 304，直接从浏览器获取数据，如果不在有效期内，返回 200，返回新数据。如果发起的请求，服务器返回重定向，浏览器再向重定向的地址重新发送请求。如果参数出错，返回 404，如果服务器出错，返回 500。如果数据一切正常，当浏览器拿到数据后，开始渲染页面同时获取 HTML 页面中的图片、音频，如果遇到 JS 文件，会停止渲染页面，执行 JS 代码，因为渲染引擎不能和 JS 引擎同时运行。最后将渲染树绘制在页面中

### 组件通信方式

1、props

2、emit

3、inject、provider

4、eventBus

5、vuex/pinia

6、$attr、$listen

### v-if 和 v-show 的区别

v-show 无论条件为 true 还是 false，都会真实渲染 dom，使用 display 来进行 dom 的显示或隐藏；而 v-if 只有当条件为 true 时才会渲染 dom

应用上：v-show 适合用于切换频繁的场景；v-if 适用于不频繁切换的场景。

### 盒子模型

盒子模型分为两种：1、标准盒子模型，2、怪异盒子模型

标准盒子模型（content-box）的宽等于 border+padding+content

怪异盒子模型（border-box）的宽等于 content

### 伪数组和数组的区别

1、类型是 object

2、不能使用数组的方法

3、可以获取长度 length

4、可以使用 for in

### 如何实现可过期的 localStorage 和其使用场景

1、惰性删除

在获取数据的时候，把数据的过期时间和当前时间做对比，如果过期时间小于当前时间，说明已经过期了，就删除数据

2、定时删除

每隔一段时间执行删除操作

使用场景：

当 token 存在 localStorage 中时。

### axios 的拦截器和原理

axios 的拦截器分为请求拦截器和响应拦截器。请求拦截器是在请求发送前所执行的，例如在 header 上加入 token；响应拦截器是在请求获取数据后所执行的，例如对状态码处理。

原理：创建一个数组，数组中存在 dispatchRequest，请求拦截器位于 dispatchRequest 前，响应拦截器位于 dispatchRequest 后，执行时利用队列的原理保证执行顺序。

### 创建 Ajax 的过程

1、创建一个 XMLHttpRequest 对象

2、创建一个 HTTP 请求，并指定请求的方法，URL，验证数据

3、设置状态变化响应方法

4、发起请求

### 重排和重绘

重排：当元素的位置和尺寸发生变化的时候，浏览器需要重新计算几何属性并摆放到正确位置的过程叫重排。

重绘：当元素样式的修改不会引起布局的变化时，叫做重绘

重排一定导致重绘，重绘不一定导致重排

可以使元素脱离标准文档流来避免重排

### Vue 列表为什么加 key

为了性能优化，vue 使用虚拟 dom，当需要更新的时候，会使用 diff 算法进行一一对比，如果没有绑定 key，会重新渲染所有元素，如果绑定了 key，更新的时候，会比较 key 是否一致，一致 key 的元素不用对其操作，优化了性能。绑定的 key 不能是数组的 index，例如当在数组插入一个新元素时，它的 index 为 0，后面所有的 index 都发生了变化，所以和不加 key 的情况一样了。

### 如何实现 vue-router 的懒加载

1、使用 import：component: () => import("")

2、使用 require：component: resolve => require([""],resolve)

主要为了性能优化，在不需要该路由的时候，不进行加载

### 前端性能优化手段

1、图片压缩和文件压缩

2、使用雪碧图/精灵图

3、节流/防抖

4、使用 http 缓存

5、使用本地缓存

6、使用 vue 的 keep-alive

7、ssr 服务器渲染

8、懒加载

### 什么是服务端渲染

SSR 全称是 Sever Side Render，页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的 html 就行，优点是首屏渲染快，对 SEO 友好，减少了网络请求。
